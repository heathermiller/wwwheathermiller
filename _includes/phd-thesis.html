<div class="row" style="padding-bottom: 28px;">
  <div class="publication">
      <div class="info col-md-9" style="padding-right: 0px;">
        <div class="title"><a href="https://infoscience.epfl.ch/record/212934/files/EPFL_TH6784.pdf">Language Support for Distributed Functional Programming</a></div>
        <div class="author">Heather Miller. Advisor: Martin Odersky.</div>
        <div class="conference">PhD thesis, EPFL, October 16<sup>th</sup>, 2015.</div>
        <span class="abstract collapsed" data-toggle="collapse" data-target="#abstract-phd">
          <div class="entypo"></div>abstract
        </span>
        <a href="https://infoscience.epfl.ch/record/212934/files/EPFL_TH6784.pdf" class="icon blue-tooltip" data-toggle="tooltip" data-placement="bottom" title="Paper PDF"><span class="icon-file-pdf" data-toggle="tooltip" data-placement="bottom"></span></a>
        <!-- {% if post.slides %}<a href="{{ post.slides }}" class="icon blue-tooltip" data-toggle="tooltip" data-placement="bottom" title="Slides"><span class="icon-presentation"></span></a>{% endif %} -->
        <div id="abstract-phd" class="collapse abstract-text">
          Software development has taken a fundamental turn. Software today has gone from simple, closed programs running on a single machine, to massively open programs, patching together user experiences byway of responses received via hundreds of network requests spanning multiple machines. At the same time, as data continues to stockpile, systems for big data analytics are on the rise. Yet despite this trend towards distributing computation, issues at the level of the language and runtime abound. Serialization is still a costly runtime affair, crashing running systems and confounding developers. Function closures are being added to APIs for big data processing for use by end-users without reliably being able to transmit them over the network. And much of the frameworks developed for handling multiple concurrent requests byway of asynchronous programming facilities rely on blocking threads, causing serious scalability issues. This thesis describes a number of extensions and libraries for the Scala programming language that aim to address these issues and to provide a more reliable foundation on which to build distributed systems. This thesis presents a new approach to serialization called pickling based on the idea of generating and composing functional pickler combinators statically. The approach shifts the burden of serialization to compile time as much as possible, enabling users to catch serialization errors at compile time rather than at runtime. Further, by virtue of serialization code being generated at compile time, our framework is shown to be significantly more performant than other state-of-the-art serialization frameworks. We also generalize our technique for generating serialization code to generic functions other than pickling. Second, in light of the trend of distributed data-parallel frameworks being designed around functional patterns where closures are transmitted across cluster nodes to large-scale persistent datasets, this thesis introduces a new closure-like abstraction and type system, called spores, that can guarantee closures to be serializable, thread-safe, or even have custom user-defined properties. Crucially, our system is based on the principle of encoding type information corresponding to captured variables in the type of a spore. We prove our type system sound, implement our approach for Scala, evaluate its practicality through a small empirical study, and show the power of these guarantees through a case analysis of real-world distributed and concurrent frameworks that this safe foundation for closures facilitates. Finally, we bring together the above building blocks, pickling and spores, to form the basis of a new programming model called function-passing. Function-passing is based on the idea of a distributed persistent data structure which stores in its nodes transformations to data rather than the distributed data itself, simplifying fault recovery by design. Lazy evaluation is also central to our model; by incorporating laziness into our design only at the point of initiating network communication, our model remains easy to reason about while remaining efficient in time and memory. We formalize our programming model in the form of a small-step operational semantics which includes a precise specification of the semantics of functional fault recovery, and we provide an open-source implementation of our model in and for Scala.
        </div>
      </div>
      <div class="abbr col-md-3"></div>
  </div>
</div>